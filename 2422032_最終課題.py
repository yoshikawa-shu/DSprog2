# -*- coding: utf-8 -*-
"""2422032_最終課題

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DRK0_PVTS7jEtoUBj9CzvlcIyNMuJ7_0
"""

import requests
from bs4 import BeautifulSoup
import pandas as pd

# URLの指定
url = "https://www.e-stat.go.jp/stat-search/files?page=1&layout=datalist&toukei=00130002&tstat=000001032793&cycle=7&year=20240&month=0"

# サイトのHTMLを取得
response = requests.get(url)

# BeautifulSoupでHTMLを解析
soup = BeautifulSoup(response.text, 'html.parser')

# CSVリンクを抽出 - find_all を使用し、エラー処理を追加
csv_links = soup.find_all('a', {'href': lambda x: x and x.endswith('.csv')})
if csv_links:
    csv_link = csv_links[0]['href'] # 最初のリンクを使用
    # 完全なURLを構築
    csv_url = f"https://www.e-stat.go.jp{csv_link}"

    # CSVファイルをダウンロード
    csv_response = requests.get(csv_url)

    # バイナリデータとしてCSVを保存
    with open('交通事故死者数.csv', 'wb') as f:
        f.write(csv_response.content)

    print("CSVファイルが正常にダウンロードされました。")

import sqlite3

# SQLite DBへの接続（DBが存在しない場合は作成される）
conn = sqlite3.connect('/content/traffic_accidents.db')
cursor = conn.cursor()

# traffic_accidentsテーブルの作成
cursor.execute('''
CREATE TABLE IF NOT EXISTS traffic_accidents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    prefecture TEXT NOT NULL,
    year INTEGER NOT NULL,
    number_of_deaths INTEGER NOT NULL
);
''')

conn.commit()

import pandas as pd

files = ['都道府県別交通事故死者数2019.csv', '都道府県別交通事故死者数2020.csv',
         '都道府県別交通事故死者数2021.csv', '都道府県別交通事故死者数2022.csv',
         '都道府県別交通事故死者数2023.csv', '都道府県別交通事故死者数2024.csv']

for file in files:
    # CSVファイルをDataFrameとして読み込む
    df = pd.read_csv(file)

    # DataFrameの内容を確認（PrefecturesとNumber of deaths列があるか）
    print(df.head())  # データの先頭を表示

    # 必要なデータが"Prefectures"と"Number of deaths"というカラム名になっている前提で
    # 年度情報をファイル名から抽出（例えば「都道府県別交通事故死者数2019.csv」→ 2019年）
    year = int(file.split('都道府県別交通事故死者数')[1].split('.csv')[0])

    # 各行をDBに挿入
    for _, row in df.iterrows():
        prefecture = row['Prefectures']
        number_of_deaths = row['Number of deaths']

        # SQL文でデータを挿入
        cursor.execute('''
        INSERT OR IGNORE INTO traffic_accidents (prefecture, year, number_of_deaths)
        VALUES (?, ?, ?)
        ''', (prefecture, year, number_of_deaths))

    # コミットして変更を反映
    conn.commit()

import matplotlib.pyplot as plt

# 年ごとの死者数の合計を棒グラフに表示
plt.figure(figsize=(10, 6))
plt.bar(df_yearly_deaths['year'], df_yearly_deaths['total_deaths'], color='skyblue')

# グラフのタイトルとラベルを設定
plt.title('Total number of traffic accident fatalities by prefecture each year', fontsize=16)
plt.xlabel('year', fontsize=14)
plt.ylabel('number of deaths', fontsize=14)

# グラフの表示
plt.tight_layout()
plt.show()

# 必要な列だけ抽出（都道府県と死者数）
df_combined = df_combined[['Prefectures', 'Number of deaths', 'year']]

# SQLデータとCSVデータをマージ（都道府県と年でマージ）
df_all = pd.concat([df_sql[['prefecture', 'year', 'number_of_deaths']],
                    df_combined.rename(columns={'Prefectures': 'prefecture', 'Number of deaths': 'number_of_deaths'})], ignore_index=True)

# 都道府県ごとの年ごとの死者数を集計
df_total_deaths = df_all.groupby(['prefecture', 'year'])['number_of_deaths'].sum().unstack(fill_value=0)

# 各都道府県の死者数の合計を計算して、死者数が多い順に並べる
df_total_deaths['total_deaths'] = df_total_deaths.sum(axis=1)
df_total_deaths_sorted = df_total_deaths.sort_values('total_deaths', ascending=False)

# グラフを作成
plt.figure(figsize=(12, 8))

# 色を年ごとに指定（Seabornのカラーパレットを使用）
colors = sns.color_palette("Set1", n_colors=6)

# 積み上げ棒グラフの作成
df_total_deaths_sorted.drop('total_deaths', axis=1).plot(kind='barh', stacked=True, color=colors, ax=plt.gca())

# グラフのラベルとタイトルを設定
plt.xlabel('Number of Deaths')
plt.ylabel('Prefecture')
plt.title('Traffic Accident Deaths by Prefecture (2019-2024)')

# レイアウトを調整して表示
plt.tight_layout()
plt.show()

# 各都道府県の死者数の変化を計算
df_total_deaths_sorted['change_2019_2024'] = df_total_deaths_sorted[2024] - df_total_deaths_sorted[2019]

# 死者数の増加率を計算（2019年から2024年までの変化率）
df_total_deaths_sorted['change_rate_2019_2024'] = (df_total_deaths_sorted['change_2019_2024'] / df_total_deaths_sorted[2019]) * 100

# 変化が大きい順に並べて表示
df_total_deaths_sorted[['change_2019_2024', 'change_rate_2019_2024']].sort_values(by='change_rate_2019_2024', ascending=False)